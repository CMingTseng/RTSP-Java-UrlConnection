package com.net.rtsp.util;import java.util.ArrayList;import java.util.EventListener;import java.util.EventObject;import java.util.List;/** * Abstract class for notification pattern. * <p> * This class handles client registration (addListener, removeListener) and * defines the pushEvent method which is used to push an event in the queue so * that it can be dispatched to client applications. * <p> * The application willing to use EventQueue has to provide a dispatchEvent * method (Dispatcher interface) which will be called each time an event has to * be dispatcher to a client listener. *  * </PRE> */public abstract class EventQueue {    static final boolean DEBUG = false;    static final String EVENT_QUEUE = "EQ";    final Class listenerType;    final Dispatcher dispatcher;    final List listeners;    private final List jobs = new ArrayList();    /**     * Create an EventQueue object.     *      * @param dispatcher     *            object used to dispatch events to client applications     */    protected EventQueue(Dispatcher dispatcher) {        this(dispatcher, EventListener.class);    }    /**     * Create an EventQueue object with a listener type. Only instances of this     * type can be added. The getListeners method will return an array whose     * component type will be this class.     *      * @param dispatcher     *            object used to dispatch events to client applications     * @param listenerType     *            the type of the listeners     */    protected EventQueue(Dispatcher dispatcher, Class listenerType) {        this(dispatcher, listenerType, new ArrayList());    }    EventQueue(Dispatcher dispatcher, Class listenerType, List listeners) {        this.dispatcher = dispatcher;        this.listenerType = listenerType;        this.listeners = listeners;    }    /**     * Register a listener.     */    public void addListener(Object listener) {        if (EventQueue.DEBUG)            com.net.rtsp.Debug.println(".addListener(" + listener + ")" + this);        if (listener == null || !listenerType.isAssignableFrom(listener.getClass()))            throw new IllegalArgumentException();        listeners.add(listener);    }    /**     * @return the number of registered listeners     */    public int getListenerCount() {        return listeners.size();    }    public EventListener[] getListeners(){        List l = listeners;        Class c = listenerType;        EventListener[] list;        synchronized (l) {            list = new EventListener[l.size()] ;            l.toArray(list);            return list;        }    }    /**     * Enqueue an event which will be sent to registered clients.     *      * @param event     *            the event to send     * @param param     *            extra parameter which can be used by tha application for its     *            own usage (e.g. param can be a constant enabling the     *            dispatcher to choose a listener method among several)     */    public void pushEvent(EventObject event) {        pushJob(new QueueJob(this, event));    }    /**     * Unregister a listener.     */    public void removeListener(Object listener) {        if (listener == null)            throw new IllegalArgumentException();        if (EventQueue.DEBUG)            com.net.rtsp.Debug.println(toString() + ".removeListener(" + listener + ")");        listeners.remove(listener);    }    public String toString() {        return super.toString() + " dispatcher " + dispatcher + " listenerType " + listenerType;    }    QueueJob dequeue() {        synchronized (this) {            return (QueueJob) jobs.remove(0);        }    }    QueueJob[] dequeueAll() {        synchronized (this) {            List list = jobs;            QueueJob[] jobs = new QueueJob[list.size()];            list.toArray(jobs);            list.clear();            return jobs;        }    }    boolean isEmpty() {        synchronized (this) {            return jobs.isEmpty();        }    }    void pushJob(QueueJob job) {        synchronized (this) {            jobs.add(job);        }    }}